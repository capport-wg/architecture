<?xml version='1.0' encoding='utf-8'?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
    please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="info" docName="draft-ietf-capport-architecture-08" ipr="trust200902" tocInclude="true" tocDepth="4" symRefs="true" sortRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 2.37.2 -->
  <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN"
    they will automatically be output with "(if approved)" -->
  <!-- ***** FRONT MATTER ***** -->
  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->
    <title abbrev="Captive Portal Architecture">Captive Portal Architecture</title>
    <seriesInfo name="Internet-Draft" value="draft-ietf-capport-architecture-08"/>
    <!-- add 'role="editor"' below for the editors if appropriate -->
    <!-- Another author who claims to be an editor -->
    <author fullname="Kyle Larose" initials="K." surname="Larose">
      <organization>Agilicus</organization>
      <address>
        <email>kyle@agilicus.com</email>
        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>
    <author fullname="David Dolson" initials="D." surname="Dolson">
      <address>
        <email>ddolson@acm.org</email>
        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>
    <author fullname="Heng Liu" initials="H." surname="Liu">
      <organization>Google</organization>
      <address>
        <email>liucougar@google.com</email>
      </address>
    </author>
    <date year="2020"/>
    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
        in the current day for you. If only the current year is specified, xml2rfc will fill
        in the current day and month for you. If the year is not the current one, it is
        necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
        purpose of calculating the expiry date).  With drafts it is normally sufficient to
        specify just the year. -->
    <!-- Meta-data Declarations -->
    <area>art</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <!-- WG name at the upperleft corner of the doc,
        IETF is fine for individual submissions.
        If this element is not present, the default is "Network Working Group",
        which is used by the RFC Editor as a nod to the history of the IETF. -->
    <keyword>plus</keyword>
    <!-- Keywords will be incorporated into HTML output
        files in a meta tag but they have no effect on text or nroff
        output. If you submit your draft to the RFC Editor, the
        keywords will be used for the search engine. -->
    <abstract>
      <t>This document describes a captive portal architecture.
        DHCP or Router Advertisements, an optional signaling protocol, and an HTTP API are used to
        provide the solution. The role of Provisioning Domains (PvDs) is
        described.
      </t>
    </abstract>
  </front>
  <middle>
    <section>
      <name>Introduction</name>
      <t>
       In this document, "Captive Portal" is used to describe a network to
       which a device may be voluntarily attached, such that network access is
       limited until some requirements have been fulfilled.  Typically a user
       is required to use a web browser to fulfill requirements imposed by the
       network operator, such as reading advertisements, accepting an
       acceptable-use policy, or providing some form of credentials.
      </t>
      <t>
       Implementations generally require a web server, some method to
       allow/block traffic, and some method to alert the user.  Common methods
       of alerting the user involve modifying HTTP or DNS traffic.
      </t>
      <t>
       This document standardizes an architecture for implementing captive
       portals while addressing most of the problems arising for current
       captive portal mechanisms. The architecture is guided by these
       principles:
      </t>
      <ul spacing="normal">
        <li>Solutions SHOULD NOT require the forging of responses from DNS or
            HTTP servers, or any other protocol.  In particular, solutions
            SHOULD NOT require man-in-the-middle proxy of TLS traffic.</li>
        <li>Solutions MUST operate at the layer of Internet Protocol (IP) or
            above, not being specific to any particular access technology such
            as Cable, WiFi or mobile telecom.</li>
        <li>Solutions MAY allow a device to be alerted that it is in a
            captive network when attempting to use any application on the
            network.</li>
        <li>Solutions SHOULD allow a device to learn that it is in a captive
            network before any application attempts to use the network.</li>
        <li>The state of captivity SHOULD be explicitly available to devices
            (in contrast to modification of DNS or HTTP, which is only
            indirectly machine-detectable by the client when it compares
            responses to well-known queries with expected responses).</li>
        <li>The architecture MUST provide a path of incremental migration,
            acknowledging a huge variety of portals and end-user device
            implementations and software versions.</li>
      </ul>
      <t>
       A side-benefit of the architecture described in this document is that
       devices without user interfaces are able to identify parameters of
       captivity.  However, this document does not yet describe a mechanism
       for such devices to escape captivity.
      </t>
      <t>
       The architecture uses the following mechanisms:
      </t>
      <ul spacing="normal">
        <li>Network provisioning protocols provide end-user devices with a
            Uniform Resource Identifier <xref target="RFC3986"/> (URI) for
            the API that end-user devices query for information about
            what is required to escape captivity. DHCP, DHCPv6, and
            Router-Advertisement options for this purpose are available in
            <xref target="RFC7710bis"/>. Other protocols (such as RADIUS),
            Provisioning Domains
            <xref target="I-D.pfister-capport-pvd"/>, or
            static configuration may also be used.
            A device MAY query this API at any time to determine whether the
            network is holding the device in a captive state.
         </li>
        <li>End-user devices can be notified of captivity with Captive Portal
            Signals in response to traffic. This notification works in response
            to any Internet protocol, and is not done by modifying protocols
            in-band.  This notification does not carry the portal URI; rather
            it provides a notification to the User Equipment that it is in a
            captive state.
        </li>
        <li>
            Receipt of a Captive Portal Signal informs an end-user device that
            it could be captive.
            In response, the device MAY query the provisioned API to obtain
            information about the network state.
            The device MAY take immediate action to satisfy the portal
            (according to its configuration/policy).
         </li>
      </ul>
      <t>
       The architecture attempts to provide confidentiality, authentication, and safety mechanisms
       to the extent possible.
      </t>
      <section>
        <name>Requirements Language</name>
	<t>
	  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
	  "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
	  "OPTIONAL" in this document are to be interpreted as described in BCP
	  14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only
	  when, they appear in all capitals, as shown here.
	</t>
      </section>
      <section>
        <name>Terminology</name>
        <t>Captive Network: A network which limits communication of attached
          devices to restricted hosts until the user has satisfied
          Captive Portal Conditions, after which access is permitted to a wider
          set of hosts (typically the Internet).</t>
        <t>Captive Portal Conditions: site-specific requirements that a user
          or device must satisfy in order to gain access to the wider network.</t>
        <t>Captive Portal Enforcement Device: The network equipment which enforces the
          traffic restriction. Also known as Enforcement Device.</t>
        <t>Captive Portal User Equipment: Also known as User Equipment. A device
          which has voluntarily joined a network for purposes of communicating
          beyond the constraints of the captive network.</t>
        <t>User Portal: The web server providing a user interface for
          assisting the user in satisfying the conditions to escape
          captivity.</t>
        <t>Captive Portal API: Also known as API. An HTTP API allowing User Equipment
          to query its state of captivity within the Captive Portal.
        </t>
        <t>Captive Portal API Server: Also known as API Server. A server hosting the
          Captive Portal API.
        </t>
        <t>Captive Portal Signal: A notification from the network used to inform the User Equipment
          that the state of its captivity could have changed.
        </t>
        <t>Captive Portal Signaling Protocol: Also known as Signaling Protocol. The protocol for
          communicating Captive Portal Signals.
        </t>
      </section>
    </section>
    <section>
      <name>Components</name>
      <section anchor="section_client">
        <name>User Equipment</name>
        <t>
       The User Equipment is the device that a user desires to be attached to
       a network with full access to all hosts on the network (e.g., to have
       Internet access). The User Equipment communication is typically
       restricted by the Enforcement Device, described in <xref target="section_capport_enforcement"/>,
       until site-specific requirements have been met.
        </t>
        <t>
        At this time we consider only devices with web browsers, with web
        applications being the means of satisfying Captive Portal Conditions.
        An example interactive User Equipment is a smart phone.
        </t>
        <t>
        The User Equipment:
        </t>
        <ul spacing="normal">
          <li>SHOULD support provisioning of the URI for the Captive Portal API (e.g., by DHCP)</li>
          <li>SHOULD distinguish Captive Portal API access per network interface, in the manner
           of Provisioning Domain Architecture <xref target="RFC7556"/>.</li>
          <li>SHOULD have a mechanism for notifying the user of the Captive Portal</li>
          <li>SHOULD have a web browser so that the user may navigate the User Portal.</li>
          <li>MAY prevent applications from using networks that do not grant full
           network access. E.g., a device connected to a mobile network may
           be connecting to a captive WiFi network; the operating system MAY
           avoid updating the default route until network access restrictions
           have been lifted (excepting access to the User Portal) in
           the new network. This has been termed "make before break".</li>
        </ul>
        <t>
        None of the above requirements are mandatory because (a) we do not wish
        to say users or devices must seek full access to the captive network,
        (b) the requirements may be fulfilled by manually visiting the captive
        portal web application, and (c) legacy devices must continue to be
        supported.
        </t>
        <t>
        If User Equipment supports the Captive Portal API, it MUST validate the API server's TLS certificate
        (see <xref target="RFC2818"/>). An Enforcement Device SHOULD allow access to
        any services that User Equipment could need to contact to perform certificate validation,
        such as OCSP responders, CRLs, and NTP servers; see Section 4.1 of 
        <xref target="I-D.ietf-capport-api"/> for more information.
        If certificate validation fails, User Equipment MUST NOT proceed with any of the behavior
        described above.
        </t>
      </section>
      <section anchor="section_provisioning">
        <name>Provisioning Service</name>
        <t>
         Here we discuss candidate mechanisms for provisioning the User
         Equipment with the URI of the API to query captive portal state and
         navigate the portal.
        </t>
        <section anchor="section_dhcp">
          <name>DHCP or Router Advertisements</name>
          <t>
           A standard for providing a portal URI using DHCP or Router
           Advertisements is described in <xref target="RFC7710bis"/>.  The
           captive portal architecture expects this URI to indicate the API described
           in <xref target="section_api"/>.
          </t>
        </section>
        <section anchor="section_pvd">
          <name>Provisioning Domains</name>
          <t>
           Although still a work in progress,
           <xref target="I-D.pfister-capport-pvd"/>
           proposes a mechanism for User Equipment to be provided with PvD
           Bootstrap Information containing the URI for the JSON-based API
           described in <xref target="section_api"/>.
          </t>
        </section>
      </section>
      <section anchor="section_api">
        <name>Captive Portal API Server</name>
        <t>
         The purpose of a Captive Portal API is to permit a query of Captive
         Portal state without interrupting the user.  This API thereby removes
         the need for User Equipment to perform clear-text "canary" HTTP queries to
         check for response tampering.
        </t>
        <t>
         The URI of this API will have been provisioned to the User Equipment.
         (Refer to <xref target="section_provisioning"/>).
        </t>
        <t>
         This architecture expects the User Equipment to query the API when the
         User Equipment attaches to the network and multiple times thereafter.
         Therefore the API MUST support multiple repeated queries from the same
         User Equipment and return the state of captivity for the equipment.
        </t>
        <t>
         At minimum, the API MUST provide: (1) the state of captivity and (2) a URI
         for the User Portal.
         </t>
         <t>
         A caller to the API needs to be presented with evidence that the content
         it is receiving is for a version of the API that it supports. For an
         HTTP-based interaction, such as in <xref target="I-D.ietf-capport-api"/>
         this might be achieved by using a content type that is unique to the
         protocol.
        </t>
        <t>
         When User Equipment receives Captive Portal Signals, the User Equipment
         MAY query the API to check the state.
         The User Equipment SHOULD rate-limit these API queries in the event of
         the signal being flooded. (See <xref target="Security"/>.)
        </t>
        <t>
         The API MUST be extensible to support future use-cases by allowing
         extensible information elements.
        </t>
        <t>
         The API MUST use TLS to ensure server authentication.
         The implementation of the API MUST ensure both confidentiality and 
         integrity of any information provided by or required by it.
        </t>
        <t>
         This document does not specify the details of the API.
        </t>
      </section>
      <section anchor="section_capport_enforcement">
        <name>Captive Portal Enforcement Device</name>
        <t>
        The Enforcement Device component restricts the network access of
        User Equipment according to site-specific policy. Typically User Equipment
        is permitted access to a small number of services and is denied general
        network access until it satisfies the Captive Portal Conditions.
        </t>
        <t>
       The Enforcement Device component:
        </t>
        <ul spacing="normal">
          <li>Allows traffic to pass for User Equipment that is permitted to
              use the network and has satisfied the Captive Portal Conditions.</li>
          <li>Blocks (discards) traffic according to the site-specific policy
            for User Equipment that has not yet satisfied the Captive Portal Conditions.</li>
          <li>May signal User Equipment using the Captive Portal Signaling protocol
           if certain traffic is blocked.</li>
          <li>Permits User Equipment that has not satisfied the Captive Portal Conditions 
          to access necessary APIs and web pages to fulfill requirements for escaping captivity.</li>
          <li>Updates allow/block rules per User Equipment in response to operations
           from the User Portal.</li>
        </ul>
      </section>
      <section anchor="section_signal">
        <name>Captive Portal Signal</name>
        <t>
        When User Equipment first connects to a network, or when there are changes in status,
        the Enforcement Device could generate a signal toward the User Equipment.  This signal
        indicates that the User Equipment might need to contact the API Server to receive
        updated information.  For instance, this signal might be generated when the end of a
        session is imminent, or when network access was denied.
        </t>

        <t>
        An Enforcement Device MUST rate-limit any signal generated in response to these conditions.  See <xref target="section_signal_risks"/> for a discussion of
        risks related to a Captive Portal Signal.
        </t>
      </section>
      <section>
        <name>Component Diagram</name>
        <t>
            The following diagram shows the communication between each component.
        </t>
        <figure anchor="components">
          <name>Captive Portal Architecture Component Diagram</name>
          <artwork><![CDATA[
o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . o
. CAPTIVE NETWORK                                               .
.                                            +--------------+   .
. +------------+   Provision API URI         | Provisioning |   .
. |            |<---------------------------+|  Service     |   .
. |   User     |                             +--------------+   .
. | Equipment  |   Query captivity status    +-------------+    .
. |            |+--------------------------->|  API        |    .
. |            |  Captivity status response  |  Server     |    .
. |            |<---------------------------+|             |    .
. |            |                             +------+------+    .
. |            |                                    | Status    .
. |            | Portal UI page requests     +------+------+    .
. |            |+--------------------------->|             |    .
. |            | Portal UI pages             | User Portal |    .
. |            |<---------------------------+|             |    .
. +------------+                             |             |    .
.     ^   ^ |                                +-------------+    .
.     |   | | Data to/from ext. network               |         .
.     |   | +-----------------> +---------------+  Allow/Deny   .
.     |   +--------------------+|               |    Rules      .
.     |                         | Enforcement   |     |         .
.     |   Captive Portal Signal | Device        | <---+         .
.     +-------------------------+---------------+               .
.                                      ^ |                      .
.                                      | |                      .
.                          Data to/from external network        .
.                                      | |                      .
o . . . . . . . . . . . . . . . . . . .| |. . . . . . . . . . . o
                                       | v
                                  EXTERNAL NETWORK
	   ]]></artwork>
        </figure>
        <t>
        In the diagram:
        </t>
        <ul spacing="normal">
          <li>During provisioning (e.g., DHCP), the User Equipment acquires
                 the URI for the Captive Portal API.</li>
          <li>The User Equipment queries the API to learn of its state of
                 captivity. If captive, the User Equipment presents the portal
                 user interface from the User Portal to the user.</li>
          <li>Based on user interaction, the User Portal directs the
                 Enforcement Device to either allow or deny external network
                 access for the User Equipment.</li>
          <li>The User Equipment attempts to communicate to the external
                 network through the Enforcement Device.</li>
          <li>The Enforcement Device either allows the User
                 Equipment's packets to the external network, or blocks the
                 packets. If blocking traffic and a signal has
                 been implemented, it may respond with a Captive Portal Signal.</li>
        </ul>
        <t>
        The Provisioning Service, API Server, and User Portal are
        described as discrete functions. An implementation might provide the
        multiple functions within a single entity.
        </t>
      </section>
    </section>
    <section anchor="ue_identity">
      <name>User Equipment Identity</name>
      <t>
             Multiple components in the architecture interact with both the User
             Equipment and each other. Since the User Equipment is the focus of
             these interactions, the components must be able to both identify the
             User Equipment from their interactions with it, and to agree
             on the identity of the User Equipment when interacting with each
             other.
      </t>
      <t>
             The methods by which the components interact restrict the type of
             information that may be used as an identifying characteristics. This
             section discusses the identifying characteristics.
      </t>
      <section anchor="id_identifiers">
        <name>Identifiers</name>
        <t>
                 An Identifier is a characteristic of the User Equipment used by
                 the components of a Captive Portal to uniquely determine which
                 specific User Equipment is interacting with them.
                 An Identifier MAY be a field contained in packets
                 sent by the User Equipment to the External Network. Or, an
                 Identifier MAY be an ephemeral property not contained in packets
                 destined for the External Network, but instead correlated with
                 such information through knowledge available to the different
                 components.
        </t>
      </section>
      <section anchor="id_recommended_props">
        <name>Recommended Properties</name>
        <t>
             The set of possible identifiers is quite large. However, in order
             to be considered a good identifier, an identifier SHOULD meet the
             following criteria. Note that the optimal identifier will likely
             change depending on the position of the components in the network
             as well as the information available to them.

             An identifier SHOULD:
        </t>
        <ul spacing="normal">
          <li>Uniquely Identify the User Equipment</li>
          <li>Be Hard to Spoof</li>
          <li>Be Visible to the API Server</li>
          <li>Be Visible to the Enforcement Device</li>
        </ul>
        <t>

             An identifier might only apply to the current point of network attachment. If the
             device moves to a different network location its identity could change.
        </t>
        <section anchor="id_recommended_unique">
          <name>Uniquely Identify User Equipment</name>
          <t>
                  Each instance of User Equipment interacting with the Captive Network MUST be
                  given an identifier that is unique among User Equipment interacting at that time.
          </t>
          <t>
                  Over time, the User Equipment assigned to an identifier value MAY change. Allowing the
                  identified device to change over time ensures that the space of possible
                  identifying values need not be overly large.
          </t>
          <t>
                  Independent Captive Portals MAY use the same identifying value to identify
                  different User Equipment. Allowing independent captive portals to reuse
                  identifying values allows the identifier to be a property of the local
                  network, expanding the space of possible identifiers.
          </t>
        </section>
        <section anchor="id_recommended_hard">
          <name>Hard to Spoof</name>
          <t>
                  A good identifier does not lend itself to being easily spoofed. At no time
                  should it be simple or straightforward for one User Equipment to
                  pretend to be another User Equipment, regardless of whether both are active
                  at the same time. This property is particularly important when the User
                  Equipment is extended externally to devices such as billing systems, or where
                  the identity of the User Equipment could imply liability.
          </t>
        </section>
        <section anchor="id_recommended_visible_api">
          <name>Visible to the API Server</name>
          <t>
                  Since the API Server will need to perform operations which rely on the identity
                  of the User Equipment, such as answering a query about
                  whether the User Equipment is captive, the API Server needs
                  to be able to relate a request to the User Equipment making
                  the request.
          </t>
        </section>
        <section anchor="id_recommended_visible_ed">
          <name>Visible to the Enforcement Device</name>
          <t>
                  The Enforcement Device will decide on a per-packet basis whether
                  the packet should be forwarded to the external network. Since
                  this decision depends on which User Equipment sent the packet, the
                  Enforcement Device requires that it be able to map the packet to its
                  concept of the User Equipment.
          </t>
        </section>
      </section>
      <section anchor="id_evaluating">
        <name>Evaluating Types of Identifiers</name>
        <t>
                 To evaluate whether a type of identifier is appropriate, one should consider
                 every recommended property from the perspective of interactions among
                 the components in the architecture. When comparing identifier types, choose
                 the one which best satisfies all of the recommended properties. The
                 architecture does not provide an exact measure of how well an identifier
                 type satisfies a given property; care should be taken in performing the
                 evaluation.
        </t>
      </section>
      <section anchor="id_examples">
        <name>Example Identifier Types</name>
        <t>
                 This section provides some example identifier types, along with some
                 evaluation of whether they are suitable types. The list of identifier types
                 is not exhaustive. Other types may be used. An important point to note
                 is that whether a given identifier type is suitable depends heavily on the
                 capabilities of the components and where in the network the components exist.
        </t>
        <section anchor="id_example_interface">
          <name>Physical Interface</name>
          <t>
                 The physical interface by which the User Equipment is attached to the
                 network can be used to identify the User Equipment. This identifier type has
                 the property of being extremely difficult to spoof: the User Equipment is
                 unaware of the property; one User Equipment cannot manipulate its
                 interactions to appear as though it is another.
          </t>
          <t>
                 Further, if only a single User Equipment is attached to a given physical
                 interface, then the identifier will be unique. If multiple User Equipment
                 is attached to the network on the same physical interface, then this type
                 is not appropriate.
          </t>
          <t>
                 Another consideration related to uniqueness of the User Equipment is that
                 if the attached User Equipment changes, both the API Server and the
                 Enforcement Device MUST invalidate their state related to the User Equipment.
          </t>
          <t>
                 The Enforcement Device needs to be aware of the physical interface,
                 which constrains the environment: it must either be part of the device providing
                 physical access (e.g., implemented in firmware), or packets traversing the network
                 must be extended to include information about the source physical interface (e.g.
                 a tunnel).
          </t>
          <t>
                 The API Server faces a similar problem, implying that it should co-exist with the
                 Enforcement Device, or that the Enforcement Device should extend requests to it
                 with the identifying information.
          </t>
        </section>
        <section anchor="id_example_IP_address">
          <name>IP Address</name>
          <t>
                  A natural identifier type to consider is the IP address of the User Equipment.
                  At any given time, no device on the network can have the same IP address
                  without causing the network to malfunction, so it is appropriate from the
                  perspective of uniqueness.
          </t>
          <t>
                  However, it may be possible to spoof the IP address, particularly for
                  malicious reasons where proper functioning of the network is not necessary
                  for the malicious actor. Consequently, any solution using the IP address
                  SHOULD proactively try to prevent spoofing of the IP address. Similarly,
                  if the mapping of IP address to User Equipment is changed, the components
                  of the architecture MUST remove or update their mapping to prevent spoofing.
                  Demonstrations of return routeability, such as that required for TCP
                  connection establishment, might be sufficient defense against spoofing,
                  though this might not be sufficient in networks that use broadcast media
                  (such as some wireless networks).
          </t>
          <t>
                  Since the IP address may traverse multiple segments of the network, more
                  flexibility is afforded to the Enforcement Device and the API Server: they
                  simply must exist on a segment of the network where the IP address is still
                  unique. However, consider that a NAT may be deployed between the User Equipment
                  and the Enforcement Device. In such cases, it is possible for the components
                  to still uniquely identify the device if they are aware of the port mapping.
          </t>
          <t>
                In some situations, the User Equipment may have multiple IP addresses, while
                still satisfying all of the recommended properties. This raises some challenges
                to the components of the network. For example, if the User Equipment tries
                to access the network with multiple IP addresses, should the Enforcement Device
                and API Server treat each IP address as a unique User Equipment, or should it
                tie the multiple addresses together into one view of the subscriber?
                An implementation MAY do either. Attention should be paid to IPv6 and the fact
                that it is expected for a device to have multiple IPv6 addresses on a single
                link. In such cases, identification could be performed by subnet, such as the /64
                to which the IP belongs.
          </t>
        </section>
      </section>
        <section anchor="context_free_uri">
          <name>Context-free URI</name>
          <t>
            A Captive Portal API needs to present information to clients
            that is unique to that client. To do this, some systems use
            information from the context of a request, such as the source
            address, to identify the UE.
          </t>
          <t>
            Using information from context rather than information from the
            URI allows the same URI to be used for different clients. However,
            it also means that the resource is unable to provide relevant
            information if the UE makes a request using a different network
            path. This might happen when UE has multiple network interfaces.
            It might also happen if the address of the API provided by DNS
            depends on where the query originates (as in split DNS
            <xref target="RFC8499"/>).
          </t>
          <t>
            Accessing the API MAY depend on contextual information. However,
            the URIs provided in the API SHOULD be unique to the UE and not
            dependent on contextual information to function correctly.
          </t>
          <t>
            Though a URI might still correctly resolve when the UE makes the
            request from a different network, it is possible that some
            functions could be limited to when the UE makes requests using the
            captive network. For example, payment options could be absent or a
            warning could be displayed to indicate the payment is not for the
            current connection.
          </t>
          <t>
            URIs could include some means of identifying the User Equipment in
            the URIs.  However, including unauthenticated User Equipment
            identifiers in the URI may expose the service to spoofing or replay
            attacks.
          </t>
        </section>
    </section>
    <section anchor="section_workflow">
      <name>Solution Workflow</name>
      <t>
      This section aims to improve understanding by describing a possible
      workflow of solutions adhering to the architecture.
      </t>
      <section>
        <name>Initial Connection</name>
        <t>
      This section describes a possible workflow when User Equipment initially
      joins a Captive Network.
        </t>
        <ol spacing="normal" type="1">
          <li>The User Equipment joins the Captive Network by acquiring a DHCP
         lease, RA, or similar, acquiring provisioning information.</li>
          <li>The User Equipment learns the URI for the Captive Portal API from the
         provisioning information (e.g., <xref target="RFC7710bis"/>).</li>
          <li>The User Equipment accesses the Captive Portal API to receive parameters
         of the Captive Network, including User Portal URI. (This step replaces
         the clear-text query to a canary URI.)</li>
          <li>If necessary, the User navigates the User Portal to gain access to the
         external network.</li>
          <li>The Captive Portal API server indicates to the Enforcement
         Device that the User Equipment is allowed to access the external network.</li>
          <li>The User Equipment attempts a connection outside the captive network</li>
          <li>If the requirements have been satisfied, the access is permitted;
         otherwise the "Expired" behavior occurs.</li>
          <li>The User Equipment accesses the network until conditions Expire.</li>
        </ol>
      </section>
      <section>
        <name>Conditions About to Expire</name>
        <t>
      This section describes a possible workflow when access is about to expire.
        </t>
        <ol spacing="normal" type="1">
          <li>Precondition: the API has provided the User Equipment with a duration
         over which its access is valid</li>
          <li>The User Equipment is communicating with the outside network</li>
          <li>The User Equipment's UI indicates that the length of time left for its access
         has fallen below a threshold</li>
          <li>The User Equipment visits the API again to validate the expiry time</li>
          <li>If expiry is still imminent, the User Equipment prompts the user to access the
         User Portal URI again</li>
          <li>The User extends their access through the User Portal</li>
          <li>The User Equipment's access to the outside network continues uninterrupted</li>
        </ol>
      </section>
      <section>
        <name>Handling of Changes in Portal URI</name>
        <t>A different Captive Portal API URI could be returned in the following cases:</t>
        <ul spacing="normal">
          <li>If DHCP is used, a lease renewal/rebind may return a different Captive
          Portal API URI.</li>
          <li>If RA is used, a new Captive Portal API URI may be specified in a new RA
          message received by end User Equipment.</li>
        </ul>
        <t>Whenever a new Portal URI is received by end User Equipment, it SHOULD discard
      the old URI and use the new one for future requests to the API.</t>
      </section>
    </section>
    <section anchor="Acknowledgments">
      <name>Acknowledgments</name>
      <t>The authors thank Lorenzo Colitti for providing the majority of the content
         for the Captive Portal Signal requirements.</t>
      <t>The authors thank various individuals for their feedback on
        the mailing list and during the IETF98 hackathon:
        David Bird,
        Erik Kline,
        Alexis La Goulette,
        Alex Roscoe,
        Darshak Thakore,
        and Vincent van Dam.
      </t>
    </section>
    <!-- Possibly a 'Contributors' section ... -->
    <section anchor="IANA">
      <name>IANA Considerations</name>
      <t>This memo includes no request to IANA.</t>
    </section>
    <section anchor="Security">
      <name>Security Considerations</name>
      <!--All drafts are required to have a security considerations section.  See RFC3552 -->
      <section>
        <name>Trusting the Network</name>
        <t>
         When joining a network, some trust is placed in the network operator.
         This is usually considered to be a decision by a user on the basis of
         the reputation of an organization. However, once a user makes such a
         decision, protocols can support authenticating that a network is operated
         by who claims to be operating it.  The Provisioning Domain
         Architecture <xref target="RFC7556"/> provides some discussion on
         authenticating an operator.
        </t>
        <t>
         Given that a user chooses to visit a Captive Portal URI, the URI location
         SHOULD be securely provided to the user's device. E.g., the DHCPv6 AUTH
         option can sign this information.
        </t>
        <t>
         If a user decides to incorrectly trust an attacking network, they might
         be convinced to visit an attacking web page and unwittingly provide
         credentials to an attacker. Browsers can authenticate servers but
         cannot detect cleverly misspelled domains, for example.
        </t>
      </section>
      <section>
        <name>Authenticated APIs</name>
        <t>
         The solution described here assumes that when the User Equipment needs to
         trust the API server, server authentication will be performed using TLS
         mechanisms.
        </t>
      </section>
      <section>
        <name>Secure APIs</name>
        <t>
           The solution described here requires that the API be secured using TLS.
           This is required to allow the User Equipment and API Server to exchange
           secrets which can be used to validate future interactions. The API MUST
           ensure the integrity of this information, as well as its confidentiality.
        </t>
      </section>
      <section anchor="section_signal_risks">
        <name>Risks Associated with the Signaling Protocol</name>
        <t>
         If a Signaling Protocol is implemented, it may be possible for any user on
         the Internet to send signals in attempt to cause the receiving equipment to
         communicate with the Captive Portal API. This has been considered, and implementations may
         address it in the following ways:
        </t>
        <ul spacing="normal">
          <li>The signal only informs the User Equipment to query the API. It does not
              carry any information which may mislead or misdirect the User Equipment.</li>
          <li>Even when responding to the signal, the User Equipment securely authenticates
               with API Servers.</li>
          <li>Accesses to the API Server are rate limited, limiting the impact of a repeated
              attack.</li>
        </ul>
      </section>
      <section>
        <name>User Options</name>
        <t>
         The Captive Portal Signal could inform the User Equipment that it is being held
         captive.  There is no requirement that the User Equipment do something
         about this.
         Devices MAY permit users to disable automatic reaction to
         Captive Portal Signals indications for privacy reasons.
         However, there would be the trade-off that the user doesn't get notified
         when network access is restricted.
         Hence, end-user devices MAY allow users to manually control captive
         portal interactions, possibly on the granularity of Provisioning
         Domains.
        </t>
      </section>
    </section>
  </middle>
  <!--  *****BACK MATTER ***** -->
  <back>
    <!-- References split into informative and normative -->
    <!-- There are 2 ways to insert reference entries from the citation libraries:
    1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
    2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
       (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

    Both are cited textually in the same manner: by using xref elements.
    If you use the PI option, xml2rfc will, by default, try to find included files in the same
    directory as the including file. You can also define the XML_LIBRARY environment variable
    with a value containing a set of directories to search.  These can be either in the local
    filing system or remote ones accessed by http (http://domain/dir/... ).-->
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <seriesInfo name="DOI" value="10.17487/RFC2119"/>
            <seriesInfo name="RFC" value="2119"/>
            <seriesInfo name="BCP" value="14"/>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
        </reference>
	<reference  anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>
	<reference anchor='RFC7710bis'>
<front>
<title>Captive-Portal Identification in DHCP / RA</title>

<author initials='W' surname='Kumari' fullname='Warren Kumari'>
    <organization />
</author>

<author initials='E' surname='Kline' fullname='Erik Kline'>
    <organization />
</author>

<date month='January' day='12' year='2020' />

<abstract><t>In many environments offering short-term or temporary Internet access (such as coffee shops), it is common to start new connections in a captive portal mode.  This highly restricts what the customer can do until the customer has authenticated.  This document describes a DHCP option (and a Router Advertisement (RA) extension) to inform clients that they are behind some sort of captive-portal device, and that they will need to authenticate to get Internet access.  It is not a full solution to address all of the issues that clients may have with captive portals; it is designed to be used in larger solutions.  The method of authenticating to, and interacting with the captive portal is out of scope of this document.  [ This document is being collaborated on in Github at: https://github.com/wkumari/draft-ekwk-capport-rfc7710bis.  The most recent version of the document, open issues, etc should all be available here.  The authors (gratefully) accept pull requests.  Text in square brackets will be removed before publication. ]</t></abstract>

</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-capport-rfc7710bis-01' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-capport-rfc7710bis-01.txt' />
</reference>
        <reference anchor="RFC7556" target="https://www.rfc-editor.org/info/rfc7556" xml:base="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7556.xml">
          <front>
            <title>Multiple Provisioning Domain Architecture</title>
            <seriesInfo name="DOI" value="10.17487/RFC7556"/>
            <seriesInfo name="RFC" value="7556"/>
            <author initials="D." surname="Anipko" fullname="D. Anipko" role="editor">
              <organization/>
            </author>
            <date year="2015" month="June"/>
            <abstract>
              <t>This document is a product of the work of the Multiple Interfaces Architecture Design team.  It outlines a solution framework for some of the issues experienced by nodes that can be attached to multiple networks simultaneously.  The framework defines the concept of a Provisioning Domain (PvD), which is a consistent set of network configuration information.  PvD-aware nodes learn PvD-specific information from the networks they are attached to and/or other sources.  PvDs are used to enable separation and configuration consistency in the presence of multiple concurrent connections.</t>
            </abstract>
          </front>
        </reference>
        <reference anchor="RFC2818" target="https://www.rfc-editor.org/info/rfc2818">
          <front>
            <title>HTTP Over TLS</title>
            <author initials="E." surname="Rescorla" fullname="E. Rescorla">
              <organization/>
            </author>
            <date year="2000" month="May"/>
            <abstract>
              <t>This memo describes how to use Transport Layer Security (TLS) to secure Hypertext Transfer Protocol (HTTP) connections over the Internet.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2818"/>
          <seriesInfo name="DOI" value="10.17487/RFC2818"/>
        </reference>
      </references>
      <references>
        <name>Informative References</name>
        <reference anchor="RFC3986" target="https://www.rfc-editor.org/info/rfc3986">
          <front>
            <title>Uniform Resource Identifier (URI): Generic Syntax</title>
            <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
              <organization/>
            </author>
            <author initials="R." surname="Fielding" fullname="R. Fielding">
              <organization/>
            </author>
            <author initials="L." surname="Masinter" fullname="L. Masinter">
              <organization/>
            </author>
            <date year="2005" month="January"/>
            <abstract>
              <t>
              A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource. This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet. The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier. This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme. [STANDARDS-TRACK]
              </t>
            </abstract>
          </front>
        <seriesInfo name="STD" value="66"/>
        <seriesInfo name="RFC" value="3986"/>
        <seriesInfo name="DOI" value="10.17487/RFC3986"/>
        </reference>
        <reference anchor="RFC8499" target="https://www.rfc-editor.org/info/rfc8499">
          <front>
            <title>DNS Terminology</title>
            <author initials="P." surname="Hoffman" fullname="P. Hoffman">
              <organization/>
            </author>
            <author initials="A." surname="Sullivan" fullname="A. Sullivan">
              <organization/>
            </author>
            <author initials="K." surname="Fujiwara" fullname="K. Fujiwara">
              <organization/>
            </author>
            <date year="2019" month="January"/>
            <abstract>
              <t>The Domain Name System (DNS) is defined in literally dozens of different RFCs.  The terminology used by implementers and developers of DNS protocols, and by operators of DNS systems, has sometimes changed in the decades since the DNS was first defined.  This document gives current definitions for many of the terms used in the DNS in a single document.</t>
              <t>This document obsoletes RFC 7719 and updates RFC 2308.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="219"/>
          <seriesInfo name="RFC" value="8499"/>
          <seriesInfo name="DOI" value="10.17487/RFC8499"/>
        </reference>
        <reference anchor="I-D.pfister-capport-pvd" xml:base="https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.pfister-capport-pvd.xml" target="http://www.ietf.org/internet-drafts/draft-pfister-capport-pvd-00.txt">
          <front>
            <title>Using Provisioning Domains for Captive Portal Discovery</title>
            <seriesInfo name="Internet-Draft" value="draft-pfister-capport-pvd-00"/>
            <author initials="P" surname="Pfister" fullname="Pierre Pfister">
              <organization/>
            </author>
            <author initials="T" surname="Pauly" fullname="Tommy Pauly">
              <organization/>
            </author>
            <date month="June" day="30" year="2018"/>
            <abstract>
              <t>Devices that connect to Captive Portals need a way to identify
              that the network is restricted and discover a method for opening
              up access.  This document defines how to use Provisioning Domain
              Additional Information to discover a Captive Portal API URI.</t>
            </abstract>
          </front>
        </reference>
        <reference anchor="I-D.ietf-capport-api">
          <front>
            <title>Captive Portal API</title>
            <author initials="T" surname="Pauly" fullname="Tommy Pauly">
              <organization/>
            </author>
            <author initials="D" surname="Thakore" fullname="Darshak Thakore">
              <organization/>
            </author>
            <date month="March" day="31" year="2020"/>
            <abstract>
              <t>This document describes an HTTP API that allows clients to interact with a Captive Portal system.  With this API, clients can discover how to get out of captivity and fetch state about their Captive Portal sessions.</t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-capport-api-06"/>
          <format type="TXT" target="http://www.ietf.org/internet-drafts/draft-ietf-capport-api-06.txt"/>
        </reference>
      </references>
    </references>
    <section anchor="app-additional">
      <name>Existing Captive Portal Detection Implementations</name>
      <t>
       Operating systems and user applications may perform various tests when
       network connectivity is established to determine if the device is
       attached to a network with a captive portal present. A common method is
       to attempt to make a HTTP request to a known, vendor-hosted endpoint with
       a fixed response. Any other response is interpreted as a signal that a
       captive portal is present. This check is typically not secured with TLS,
       as a network with a captive portal may intercept the connection, leading
       to a host name mismatch. This has been referred to as a "canary" request
       because, like the canary in the coal mine, it can be the first sign
       that something is wrong.
      </t>

      <t>
       Another test that can be performed is a DNS lookup to a known address
       with an expected answer. If the answer differs from the expected answer,
       the equipment detects that a captive portal is present.
       DNS queries over TCP or HTTPS are less likely to be modified than DNS
       queries over UDP due to the complexity of implementation.
      </t>

      <t>
       The different tests may produce different conclusions, varying by
       whether or not the implementation treats both TCP and UDP traffic,
       and by which types of DNS are intercepted.
      </t>

      <t>
       Malicious or misconfigured networks with a captive portal present may
       not intercept these requests and choose to pass them through or decide to
       impersonate, leading to the device having a false negative.
      </t>
    </section>
  </back>
</rfc>
